$date
	Sat May 14 20:58:45 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module CPU_tb $end
$var wire 4 ! readData [3:0] $end
$var wire 2 " numRz [1:0] $end
$var wire 2 # numRy [1:0] $end
$var wire 2 $ numRx [1:0] $end
$var wire 4 % aluResult [3:0] $end
$var wire 4 & Rz [3:0] $end
$var wire 4 ' Ry [3:0] $end
$var wire 4 ( Rx [3:0] $end
$var wire 1 ) RegWrite $end
$var wire 1 * Reg2Loc $end
$var wire 4 + PC [3:0] $end
$var wire 1 , MemWrite $end
$var wire 1 - MemRead $end
$var wire 16 . Instruction [15:0] $end
$var wire 1 / Branch $end
$var reg 1 0 clock $end
$scope module imem $end
$var wire 4 1 PC [3:0] $end
$var reg 16 2 Instruction [15:0] $end
$upscope $end
$scope module main $end
$var wire 16 3 Instruction [15:0] $end
$var wire 1 0 clock $end
$var wire 4 4 tempImmediate [3:0] $end
$var wire 1 5 tempZero $end
$var wire 4 6 tempALUInput2 [3:0] $end
$var wire 4 7 readData [3:0] $end
$var wire 2 8 numRy [1:0] $end
$var wire 4 9 nextnextPC [3:0] $end
$var wire 1 : nextPCZero $end
$var wire 4 ; nextPC [3:0] $end
$var wire 1 < branchPCZero $end
$var wire 4 = branchPC [3:0] $end
$var wire 4 > aluResult [3:0] $end
$var wire 4 ? Rz [3:0] $end
$var wire 4 @ Ry [3:0] $end
$var wire 4 A Rx [3:0] $end
$var reg 1 B ALUSrc $end
$var reg 1 / Branch $end
$var reg 1 C Jump $end
$var reg 1 - MemRead $end
$var reg 1 , MemWrite $end
$var reg 1 D MemtoReg $end
$var reg 4 E Opcode [3:0] $end
$var reg 4 F PC [3:0] $end
$var reg 1 * Reg2Loc $end
$var reg 1 ) RegWrite $end
$var reg 1 G Uncondbranch $end
$var reg 4 H aluOpcode [3:0] $end
$var reg 2 I numRx [1:0] $end
$var reg 2 J numRz [1:0] $end
$var reg 1 K tempBranch $end
$var reg 2 L tempRx [1:0] $end
$var reg 2 M tempRy [1:0] $end
$scope module adderNextPC $end
$var wire 4 N A [3:0] $end
$var wire 4 O B [3:0] $end
$var wire 4 P aluOpcode [3:0] $end
$var reg 1 : Zero $end
$var reg 4 Q aluResult [3:0] $end
$upscope $end
$scope module adderShiftPC $end
$var wire 4 R A [3:0] $end
$var wire 4 S B [3:0] $end
$var wire 4 T aluOpcode [3:0] $end
$var reg 1 < Zero $end
$var reg 4 U aluResult [3:0] $end
$upscope $end
$scope module alu $end
$var wire 4 V aluOpcode [3:0] $end
$var wire 4 W B [3:0] $end
$var wire 4 X A [3:0] $end
$var reg 1 5 Zero $end
$var reg 4 Y aluResult [3:0] $end
$upscope $end
$scope module mux1 $end
$var wire 1 C Jump $end
$var wire 4 Z branchPC [3:0] $end
$var wire 4 [ nextPC [3:0] $end
$var reg 4 \ nextnextPC [3:0] $end
$upscope $end
$scope module mux2 $end
$var wire 1 * Reg2Loc $end
$var wire 2 ] input1 [1:0] $end
$var wire 2 ^ input2 [1:0] $end
$var reg 2 _ out [1:0] $end
$upscope $end
$scope module mux3 $end
$var wire 1 B ALUSrc $end
$var wire 4 ` input2 [3:0] $end
$var wire 4 a input1 [3:0] $end
$var reg 4 b out [3:0] $end
$upscope $end
$scope module mux4 $end
$var wire 1 D MemtoReg $end
$var wire 4 c aluResult [3:0] $end
$var wire 4 d readData [3:0] $end
$var reg 4 e out [3:0] $end
$upscope $end
$upscope $end
$scope module mem3 $end
$var wire 1 - MemRead $end
$var wire 1 , MemWrite $end
$var wire 4 f address [3:0] $end
$var wire 4 g writeData [3:0] $end
$var reg 4 h readData [3:0] $end
$upscope $end
$scope module rmem $end
$var wire 1 ) RegWrite $end
$var wire 4 i Rz [3:0] $end
$var wire 2 j numRx [1:0] $end
$var wire 2 k numRy [1:0] $end
$var wire 2 l numRz [1:0] $end
$var reg 4 m Rx [3:0] $end
$var reg 4 n Ry [3:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx n
bx m
bx l
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bz b
bx a
bz `
bx _
bx ^
bx ]
b1 \
b1 [
bx Z
bx Y
bx X
bx W
bx V
bx U
b10 T
bz S
b0 R
b1 Q
b10 P
b1 O
b0 N
bx M
bx L
0K
bx J
bx I
bx H
0G
b0 F
bx E
zD
0C
zB
bx A
bx @
bx ?
bx >
bx =
0<
b1 ;
0:
b1 9
bx 8
bx 7
bz 6
x5
bz 4
bx 3
bx 2
b0 1
00
0/
bx .
z-
z,
b0 +
z*
z)
bx (
bx '
bx &
bx %
bx $
bx #
bx "
bx !
$end
#1
bx 6
bx b
0B
0,
0-
1)
0D
0*
10
#2
b10 9
b10 \
b10 ;
b10 Q
b10 [
b1 +
b1 1
b1 F
b1 N
b1 R
00
#3
10
#4
b11 9
b11 \
b11 ;
b11 Q
b11 [
b10 +
b10 1
b10 F
b10 N
b10 R
00
#5
10
#6
b100 9
b100 \
b100 ;
b100 Q
b100 [
b11 +
b11 1
b11 F
b11 N
b11 R
00
#7
10
#8
b101 9
b101 \
b101 ;
b101 Q
b101 [
b100 +
b100 1
b100 F
b100 N
b100 R
00
#9
10
#10
b110 9
b110 \
b110 ;
b110 Q
b110 [
b101 +
b101 1
b101 F
b101 N
b101 R
00
#11
10
#12
b111 9
b111 \
b111 ;
b111 Q
b111 [
b110 +
b110 1
b110 F
b110 N
b110 R
00
#13
10
#14
b1000 9
b1000 \
b1000 ;
b1000 Q
b1000 [
b111 +
b111 1
b111 F
b111 N
b111 R
00
#15
10
#16
b1001 9
b1001 \
b1001 ;
b1001 Q
b1001 [
b1000 +
b1000 1
b1000 F
b1000 N
b1000 R
00
#17
10
#18
b1010 9
b1010 \
b1010 ;
b1010 Q
b1010 [
b1001 +
b1001 1
b1001 F
b1001 N
b1001 R
00
#19
10
#20
b1011 9
b1011 \
b1011 ;
b1011 Q
b1011 [
b1010 +
b1010 1
b1010 F
b1010 N
b1010 R
00
#21
10
#22
b1100 9
b1100 \
b1100 ;
b1100 Q
b1100 [
b1011 +
b1011 1
b1011 F
b1011 N
b1011 R
00
#23
10
#24
b1101 9
b1101 \
b1101 ;
b1101 Q
b1101 [
b1100 +
b1100 1
b1100 F
b1100 N
b1100 R
00
#25
10
#26
b1110 9
b1110 \
b1110 ;
b1110 Q
b1110 [
b1101 +
b1101 1
b1101 F
b1101 N
b1101 R
00
#27
10
#28
b1111 9
b1111 \
b1111 ;
b1111 Q
b1111 [
b1110 +
b1110 1
b1110 F
b1110 N
b1110 R
00
#29
10
#30
b0 9
b0 \
1:
b0 ;
b0 Q
b0 [
b1111 +
b1111 1
b1111 F
b1111 N
b1111 R
00
